/**
 * Created by: victor on 2/1/15.
 * Source: communicationManager.js
 * Author: victor
 * Description: The communication manager is responsible of managing all the WWC network
 *              operations. This includes, add, modify, and remove sandboxes, this is, keep
 *              track of the global state of the WWC sandBoxes,maintain communication with the server,
 *              and socket states. It will also manage new socket.io connections, new RTC connections,
 *              receive, and send data through the network.
 */
var emitter = require('events').EventEmitter, /* Event Emitter Module */
    util = require('util');
/* NodeJS Utils Module */

function CommunicationManager() {
    "use strict";

    var Map = require("collections/map"), /* Map Collection Data Structure Class */
        sandBoxesMap = new Map(), /* The Map of SandBoxes */
        serverURL = "", /* The Server URL */
        listeners = {}, /* Event listeners for internal changes object */
        self = this;
    /* Storing this reference for async areas */

    /* Events registration object */
    listeners = {
        addEvent: {isPresent: false, callBack: null},
        changeEvent: {isPresent: false, callBack: null},
        removeEvent: {isPresent: false, callBack: null}
    };

    /**
     * Sets the Server URL string for this communicator.
     * @public
     * @URL (string) The server URL string.
     */
    self.setServerURL = function (URL) {
        serverURL = URL;
    };

    /**
     * Return the server URL of this communicator.
     * @public
     * @return {string} The server URL string.
     */
    self.getServerURL = function () {
        return serverURL;
    };


    /*************************** SANDBOX MAP METHODS *********************************/

    /**
     * Returns the length of the connected sandboxes collection.
     * @public
     * @return {integer} The current number of connected sandboxes.
     */
    self.getSandBoxCount = function () {
        return sandBoxesMap.length;
    };

    /**
     * Check if the current SandBox ID is present in the connected sandboxes.
     * @public
     * @key {integer} The ID of the sandbox socket.
     * @return {boolean} True or false depending of the existence of the
     *                   key in the map.
     */
    self.hasSandBox = function (key) {
        return sandBoxesMap.has(key);
    };

    /**
     * Get sandBox for the given ID.
     * @public
     * @key {integer} The ID of the sandbox socket.
     * @return {type} Description
     */
    self.getSandBox = function (key) {
        return sandBoxesMap.get(key);
    };

    /**
     * Get all current connected SandBoxes IDs.
     * @public
     * @return {array} Collection of all sandboxes keys.
     */
    self.getSandBoxesKeys = function () {
        return sandBoxesMap.keys();
    };

    /**
     * Get all connected SandBoxes.
     * @public
     * @return {array} Collection of all sandboxes.
     */
    self.getSandBoxes = function () {
        return sandBoxesMap.values();
    };

    /**
     * Returns an object with each property name and value corresponding to the ID and SandBoxes in this collection.
     * @public
     * @return {object} Object with each sandBox as members in the form of ID:SandBox.
     */
    self.sandBoxesToObject = function () {
        return sandBoxesMap.toObject();
    };

    /**
     * Returns a JSON object of the SandBoxes map.
     * @public
     * @return {string} JSON string.
     */
    self.sandBoxesToJSON = function () {
        return sandBoxesMap.toJSON();
    };

    /**
     * Return all SandBoxes with its IDs in pairs.
     * @public
     * @return {array} Collection all [ID, SandBox] entries.
     */
    self.getIDAndSandBoxPairs = function () {
        return sandBoxesMap.entries();
    };

    /**
     * Maps each SandBox to a given callback function, returns the processed value in a collection
     * in the same order.
     * @public
     * @callback {function} function for the Sandbox mapping.Must contain
     *                      a parameter for the sandbox, and a return for the
     *                      mapped result.
     * @return {array} Collection mapped results.
     */
    self.mapSandBoxes = function (callback) {
        return sandBoxesMap.map(callback);
    };

    /**
     * Returns an array with each SandBox from this collection that passes the given test.
     * @public
     * @callback {function} function for the filtering.Must contain
     *                      a parameter for the sandbox, and a return a boolean,
     *                      true to include the sandbox in the collection, or
     *                      false to exclude the sandbox.
     * @return {array} Collection filtered sandboxes.
     */
    self.filterSandBoxes = function (callback) {
        return sandBoxesMap.filter(callback);
    };

    /**
     * Calls the callback for each Sandbox in the collection
     * @public
     * @callback {function} function for the foreach iteration.
     */
    self.forEachSandBox = function (callback) {
        sandBoxesMap.forEach(callback);
    };

    /**
     * Returns an array of [key, class] entries where every SandBox
     * from the collection is placed into the same equivalence
     * class if they return the same key through the given callback.
     * @public
     * @callback {function} function for the grouping.Must contain
     *                      a parameter for the sandbox, and a return a key to be used
     *                      by the grouping.
     * @return {array} Collection of [key, class] pairs according to the grouping.
     */
    self.groupSandBoxes = function (callback) {
        return sandBoxesMap.group(callback);
    };

    /**
     * Returns whether any sandBox in this collection passes a given test.
     * @public
     * @callback {function} function for the checking.Must contain
     *                      a parameter for the sandbox, and a return a boolean that
     *                      indicates if pass or fail the test.
     * @return {boolean} True if at least one sandBox passes the test, false if otherwise.
     */
    self.someSandBoxes = function (callback) {
        return sandBoxesMap.some(callback);
    };

    /**
     * Returns whether every SandBox in this collection passes a given test.
     * @public
     * @callback {function} function for the checking.Must contain
     *                      a parameter for the sandbox, and a return a boolean that
     *                      indicates if pass or fail the test.
     * @return {boolean} True if all sandBox passes the test, false if otherwise.
     */
    self.everySandBoxes = function (callback) {
        return sandBoxesMap.every(callback);
    };


    /*************************** LISTENER METHODS *********************************/

    /**
     * Adds an event listener to be executed when a new sandBox is added(connected).
     * @public
     * @listener {function} Provided function listener, must have at least 1 parameter for
     *                      just added SandBox.Additional parameters will be ignored.
     */
    self.addSandBoxConnectedListener = function (listener) {
        listeners.addEvent.isPresent = true;
        listeners.addEvent.callBack = listener;
    };

    /**
     * Adds an event listener to be executed when a sandBox is modified(updated).
     * @public
     * @listener {function} Provided function listener, must have at least 2 parameters, one for
     *                      the old version of the modified SandBox, and a second parameter for
     *                      the new version of the sandBox object. The function must look like
     *                      function(old, new). Additional parameters will be ignored.
     */
    self.addSandBoxChangedListener = function (listener) {
        listeners.changeEvent.isPresent = true;
        listeners.changeEvent.callBack = listener;
    };

    /**
     * Adds an event listener to be executed when a sandBox is removed(disconnected).
     * @public
     * @listener {function} Provided function listener, must have at least 1 parameter for
     *                      just removed SandBox.Additional parameters will be ignored.
     */
    self.addSandBoxDisconnectedListener = function (listener) {
        listeners.removeEvent.isPresent = true;
        listeners.removeEvent.callBack = listener;
    };

    /**
     * Removes the event listener that executes when a sandBox is added(Connected).
     * @public
     */
    self.removeSandBoxConnectedListener = function () {
        listeners.addEvent.isPresent = false;
        listeners.addEvent.callBack = null;
    };

    /**
     * Removes the event listener that executes when a sandBox is modified(updated).
     * @public
     */
    self.removeSandBoxChangedListener = function () {
        listeners.changeEvent.isPresent = false;
        listeners.changeEvent.callBack = null;
    };

    /**
     * Removes the event listener that executes when a sandBox is removed(disconnected).
     * @public
     */
    self.removeSandBoxDisconnectedListener = function () {
        listeners.removeEvent.isPresent = false;
        listeners.removeEvent.callBack = null;
    };

}

/* extend the EventEmitter class using our Communication Manager class */
util.inherits(CommunicationManager, emitter);
/* we specify that this module is a reference to the Communication Manager class */
module.exports = CommunicationManager;